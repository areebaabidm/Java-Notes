# Java Terminologies

## Java Virtual Machine (JVM)

The Java Virtual Machine (JVM) is a crucial component of the Java Runtime Environment (JRE) and Java Development Kit (JDK). It's an abstract machine that provides an execution environment for running Java bytecode.

Here's a breakdown of its functions and significance:

1. **Execution of Java Bytecode**: When a Java program is compiled, it's translated into platform-independent bytecode. The JVM interprets and executes this bytecode.
2. **Platform Independence**: JVM plays a critical role in achieving Java's "Write Once, Run Anywhere" (WORA) principle. It abstracts the underlying hardware and operating system differences, allowing compiled Java programs to run on any device or platform that has a compatible JVM installed.
3. **Memory Management**: JVM manages memory allocation and deallocation through processes like garbage collection, which automatically reclaims memory occupied by objects that are no longer in use.
4. **Optimisation and Performance**: Modern JVM implementations incorporate various optimisation techniques, including Just-In-Time (JIT) compilation. JIT compilation dynamically translates bytecode into native machine code at runtime, improving performance by executing frequently used code segments more efficiently.
5. **Security**: JVM provides a secure environment by implementing various security features like sandboxing, which restricts potentially malicious actions that a Java program can perform, preventing unauthorised access to resources.
6. **Debugging and Profiling**: JVM allows developers to monitor and analyze Java applications by providing tools for debugging, profiling, and monitoring memory usage, thread behavior, and performance metrics.

The JVM serves as an intermediary between compiled Java code and the underlying hardware and operating system. Different vendors provide JVM implementations adhering to the Java specifications, ensuring compatibility and enabling Java programs to run uniformly across diverse platforms without requiring recompilation.

## Bytecode

Bytecode in Java refers to the intermediate machine-readable code that is generated by the Java compiler during the compilation of Java source code (.java files). Instead of compiling the Java code directly into native machine code that can only run on a specific hardware architecture, the Java compiler translates the source code into bytecode (.class files).

Here are some key points about Java bytecode:

1. **Platform Independence**: Bytecode is a set of instructions that is not specific to any particular hardware or operating system. It is designed to be executed by the Java Virtual Machine (JVM), which provides a platform-independent runtime environment.
2. **Portability**: Since bytecode is not tied to any specific system, it can be executed on any device or platform that has a compatible JVM installed. This feature is fundamental to Java's "Write Once, Run Anywhere" (WORA) principle.
3. **Intermediate Representation**: Bytecode serves as an intermediate representation of the Java program. It is a low-level representation of the source code that can be executed by the JVM.
4. **Security**: Bytecode adds a layer of security to Java programs. Before execution, the JVM verifies the bytecode to ensure that it adheres to certain security constraints and does not perform any malicious operations. This verification helps in preventing unauthorised actions and enhancing the overall security of Java applications.
5. **Optimisation and Execution**: When the Java program is run, the JVM interprets the bytecode line by line, or in some cases, dynamically compiles it into native machine code (using Just-In-Time compilation) for improved performance.

## Java Development Kit (JDK)

The Java Development Kit (JDK) is a software development kit provided by Oracle Corporation (previously by Sun Microsystems) that consists of tools, libraries, and resources for developing Java-based applications. It's a comprehensive package that includes everything needed to develop, debug, and run Java programs.

Key components of the JDK include:

1. **Java Compiler (javac)**: The Java compiler translates Java source code (.java files) into bytecode (.class files) that can be executed by the Java Virtual Machine (JVM).
2. **Java Runtime Environment (JRE)**: The JDK includes a complete JRE, which is required to run Java applications. It contains the JVM, class libraries, and other necessary resources for executing Java programs.
3. **Development Tools**: The JDK provides various development tools, such as the Java Debugger (jdb), Java Archive Tool (jar), JavaDoc for generating documentation from source code comments, and other utilities that assist in the development process.
4. **Java API Libraries**: It includes a vast collection of class libraries, APIs (Application Programming Interfaces), and frameworks that offer pre-written code for common functionalities. These libraries cover a wide range of tasks, including I/O operations, networking, database connectivity, GUI development, and more.
5. **JavaFX and Other Tools**: In addition to core Java components, the JDK also provides JavaFX for building rich and interactive user interfaces, as well as other tools for performance monitoring, profiling, and debugging.

Developers use the JDK to create Java applications, applets, and other software. It allows them to write code, compile it into bytecode, debug and test applications, and package them for distribution. The JDK is available for various operating systems, including Windows, mac OS, and Linux, enabling developers to create platform-independent Java applications.

When someone intends to develop Java applications, the JDK is the primary tool set they'll utilise for coding, compiling, testing, and deploying their software.

## Java Runtime Environment (JRE)

The Java Runtime Environment (JRE) is a part of the Java Development Kit (JDK) and is a critical component for running Java applications. It includes the Java Virtual Machine (JVM), class libraries, and other runtime resources necessary for executing Java programs.

Key components and functionalities of the Java Runtime Environment (JRE) include:

1. **Java Virtual Machine (JVM)**: The JVM is an abstract computing machine that provides an execution environment for Java bytecode. It interprets or compiles Java bytecode into native machine code that the underlying hardware can understand.
2. **Class Libraries**: The JRE contains a vast set of class libraries and APIs that offer pre-built functions and tools for various tasks such as input/output (I/O) operations, networking, database connectivity, graphical user interface (GUI) development, and more. These libraries facilitate the execution of Java programs by providing essential functionalities.
3. **Runtime Environment**: It provides the necessary runtime environment for Java applications to run on different devices and operating systems. This supports Java's "Write Once, Run Anywhere" (WORA) principle, allowing Java programs to be portable across diverse platforms without modification.
4. **Java Deployment Technologies**: The JRE includes tools and technologies for deploying Java applications on the web (Java applets), on desktops, or in server environments.
5. **Security Features**: The JRE incorporates security features such as the Java Security Manager, which controls access to resources and prevents unauthorised operations, helping to maintain a secure runtime environment.
6. **Automatic Memory Management (Garbage Collection)**: The JRE manages memory allocation and deallocation through the garbage collection process, automatically freeing up memory occupied by objects that are no longer in use.

The JRE is essential for end-users who want to run Java applications on their systems. It needs to be installed on a computer to execute Java-based software, as it provides the necessary runtime support and libraries. While the JDK includes the JRE, for end-users who only require the ability to run Java programs, installing the JRE alone suffices without the need for development tools provided by the JDK.

## Garbage Collector

In Java, the Garbage Collector (GC) is an automatic memory management system responsible for reclaiming memory occupied by objects that are no longer in use or reachable by the application. It is an essential part of the Java Virtual Machine (JVM) and helps in managing the allocation and deallocation of memory dynamically during the execution of Java programs.

Here's how the Garbage Collector works in Java:

1. **Memory Allocation**: When a Java program creates objects (instances of classes), memory is allocated for these objects on the heap, which is the area of memory used for dynamic memory allocation in Java.
2. **Reference Tracking**: Java uses a mechanism called "reference counting" to determine which objects are no longer in use. Objects that are referenced by variables or other objects in the application are considered reachable.
3. **Mark-and-Sweep Algorithm**: The most commonly used Garbage Collection algorithm in Java is the Mark-and-Sweep algorithm. Periodically, the Garbage Collector runs in the background, starting with the root objects (objects referenced directly by the application) and traverses the object graph, marking objects that are still reachable.
4. **Identifying Unreachable Objects**: Any objects that are not marked during the traversal are considered unreachable or "garbage" because they are no longer accessible or referenced by the application.
5. **Reclaiming Memory**: Once the Garbage Collector identifies the unreachable objects, it proceeds with the sweep phase, where it releases the memory occupied by these objects, making it available for future allocations.
6. **Memory Compaction (Optional)**: Some Garbage Collectors may perform memory compaction after reclaiming memory. This process involves rearranging the memory to reduce fragmentation, improving the efficiency of memory usage.
7. **Automatic Process**: The Garbage Collector runs automatically in the background without the need for explicit memory management from the programmer. However, developers can influence GC behaviour by configuring JVM parameters related to garbage collection.

Java's Garbage Collector eliminates the need for manual memory management and helps prevent memory leaks by automatically reclaiming memory from unused objects. However, inefficient use of objects or holding onto references longer than necessary can still impact performance. Understanding how the Garbage Collector operates can help developers optimise memory usage and application performance in Java programs.

## Java Classpath

In Java, the classpath is a parameter that specifies the location or locations in the file system where the Java Virtual Machine (JVM) and Java compiler (javac) should look for classes and resources required by a Java program. It defines the set of directories or JAR (Java Archive) files that contain compiled bytecode (.class files) and other resources needed for the execution or compilation of Java applications.

The classpath is a critical concept when working with Java, especially when dealing with external libraries, third-party dependencies, or when organising your own code into packages and classes.

Here are some important points about the Java classpath:

1.  **Setting the Classpath**: The classpath can be set using the `-classpath` or `-cp` command-line option when running Java programs or compiling Java source files. It can also be specified using an environment variable called `CLASSPATH`.

    Example using command line:

    ```sh
    java -cp /path/to/myclasses:/path/to/lib/* com.example.MainClass
    ```
2. **Classpath Entries**: Classpath entries can include directories containing .class files, individual .class files, or JAR files (which may contain multiple .class files and resources). Each entry in the classpath is separated by a platform-specific path separator (semicolon ';' in Windows, colon ':' in Unix-like systems).
3. **Search Order**: When a Java program is executed or compiled, the JVM or compiler searches for classes and resources in the specified classpath entries in the order they are provided. It looks for the required classes starting from the beginning of the classpath and moves to the next entry if the class/resource is not found.
4. **Default Classpath**: If the classpath is not explicitly set, the JVM uses a default classpath, which typically includes the current directory (`.`) and the system libraries.
5. **Managing Dependencies**: Properly configuring the classpath is crucial for managing dependencies and ensuring that your Java programs can access required classes and resources from external libraries or other parts of your application.
6. **Class Loading**: The classpath plays a significant role in the Java class-loading mechanism, allowing the JVM to load classes and resources dynamically at runtime when they are needed by the application.

Understanding and properly managing the classpath is essential for building, executing, and maintaining Java applications, especially when working with multiple libraries or modules that require different sets of classes and resources. Incorrect classpath configuration can lead to ClassNotFoundException or NoClassDefFoundError when Java cannot find the necessary classes or resources during runtime.
